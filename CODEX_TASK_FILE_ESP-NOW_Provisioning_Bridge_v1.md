CODEX TASK FILE — ESP-NOW Provisioning Bridge v1 (Channel 6, unencrypted)
Scope

Implement a provisioning system consisting of:

Bridge ESP32 firmware (USB/Serial ↔ ESP-NOW)

Tag/Anchor firmware module (ESP-NOW provisioning RX/TX + NVS storage)

Reference server client (Python pyserial)

Transport:

Server ↔ Bridge: NDJSON over Serial

Bridge ↔ Device (Tag/Anchor): ESP-NOW, channel 6, no encryption
Addressing:

device_id is the ESP-NOW MAC of the target device.

Concurrency:

Bridge supports one provisioning job at a time (BUSY otherwise).

1) Fixed Radio Configuration (MUST)

WiFi mode: WIFI_MODE_STA

Channel: 6

Secondary channel: none

ESP-NOW encryption: disabled

Bridge initialization MUST perform:

esp_wifi_set_mode(WIFI_MODE_STA)

esp_wifi_set_channel(6, WIFI_SECOND_CHAN_NONE)

esp_now_init()

Device initialization MUST perform the same (channel 6).

2) Server ↔ Bridge Serial Protocol (NDJSON) (MUST)
2.1 Line framing

Each message is exactly one JSON object terminated by \n.

Max line length: 4096 bytes. If exceeded: respond with SERIAL_OVERFLOW.

2.2 Common fields

v (int) must be 1

id (string) request id (server-generated)

op (string) operation

2.3 Operations
hello

REQ:

{"v":1,"id":"...","op":"hello","client":"provision_server","cap":["provision","readback","reboot"]}


RESP:

{"v":1,"id":"...","op":"hello_ack","bridge":"prov-esp32","fw":"<semver>","serial":"<chipid>","cap":["provision","readback","reboot"],"status":"ok"}

provision_write

REQ:

{
  "v":1,"id":"...","op":"provision_write",
  "device_id":"AA:BB:CC:DD:EE:FF",
  "auth":{"token":"<shared>"},
  "cfg":{
    "wifi":{"ssid":"...","pass":"...","dhcp":true},
    "mqtt":{"host":"...","port":1883,"user":"...","pass":"...","topic_prefix":"uwb"},
    "sys":{"timezone":"Europe/Zurich","log_level":"info"}
  },
  "apply":true,
  "reboot":true,
  "timeout_ms":8000
}


RESP success:

{"v":1,"id":"...","op":"provision_write_ack","device_id":"AA:BB:CC:DD:EE:FF","status":"ok","detail":"stored","t_ms":123}


RESP error:

{"v":1,"id":"...","op":"provision_write_ack","device_id":"AA:BB:CC:DD:EE:FF","status":"error","err":{"code":"NO_ACK","msg":"device did not respond"}}

provision_read

REQ:

{"v":1,"id":"...","op":"provision_read","device_id":"AA:BB:CC:DD:EE:FF","auth":{"token":"<shared>"},"fields":["wifi.ssid","mqtt.host","mqtt.port"],"timeout_ms":5000}


RESP:

{"v":1,"id":"...","op":"provision_read_ack","device_id":"AA:BB:CC:DD:EE:FF","status":"ok","data":{"wifi":{"ssid":"StageNet"},"mqtt":{"host":"192.168.1.10","port":1883}}}

reboot

REQ:

{"v":1,"id":"...","op":"reboot","device_id":"AA:BB:CC:DD:EE:FF","auth":{"token":"<shared>"},"mode":"normal","timeout_ms":4000}


RESP:

{"v":1,"id":"...","op":"reboot_ack","device_id":"AA:BB:CC:DD:EE:FF","status":"ok"}

2.4 Error codes (Bridge MUST use)

BAD_REQUEST

UNSUPPORTED_OP

BUSY

SERIAL_OVERFLOW

SECURITY_DENIED

DEVICE_NOT_FOUND

PROPRIETARY_TX_FAIL

NO_ACK

NACK

TIMEOUT

INTERNAL

Error response format:

{"v":1,"id":"...","op":"<op>_ack","device_id":"...","status":"error","err":{"code":"<CODE>","msg":"..."}}

3) Bridge ↔ Device ESP-NOW App Protocol (MUST)
3.1 Frame header (binary, little endian)

All ESP-NOW payloads MUST start with:

Field	Size	Notes
magic	2	0x50 0x42 ("PB")
ver	1	0x01
msg_type	1	see table
flags	1	bit0 ack_req, bit1 is_frag, bit2 last_frag
seq	2	sequence number generated by Bridge per job
frag_idx	1	0..N (valid if is_frag)
frag_cnt	1	total fragments (valid if is_frag)
payload_len	2	length of this fragment payload
crc16	2	CRC-16/CCITT-FALSE over header (excluding crc16) + payload
3.2 msg_type

0x01 PING

0x02 PING_ACK

0x10 WRITE_CFG

0x11 WRITE_ACK

0x12 READ_CFG

0x13 READ_ACK

0x14 APPLY

0x15 APPLY_ACK

0x16 REBOOT

0x17 REBOOT_ACK

0x7E NACK

0x7F ERROR

3.3 Payload encoding (MUST)

Use CBOR for structured data.

WRITE_CFG payload: CBOR map:

token (string)

cfg (map) exactly as received from Serial cfg

READ_CFG payload: CBOR map:

token (string)

fields (array of strings)

READ_ACK payload: CBOR map:

data map containing requested fields (nested)

NACK payload: CBOR map:

code (string) e.g. SECURITY_DENIED, INVALID_FIELD, STORE_FAIL

msg (string)

3.4 MTU / fragmentation (MUST)

Define constants (Bridge and Device must match):

ESPNOW_MAX_TOTAL = 240 bytes (conservative payload limit)

PB_HDR_SIZE = 2+1+1+1+2+1+1+2+2 = 13 bytes

PB_MAX_PAYLOAD_PER_FRAME = 200 bytes (safe)

If CBOR payload > PB_MAX_PAYLOAD_PER_FRAME:

split into N fragments

set flags.is_frag=1

set frag_idx, frag_cnt

set flags.last_frag=1 on last fragment

3.5 Reassembly (MUST)

Receiver MUST:

buffer fragments per (src_mac, seq, msg_type)

require all fragments [0..frag_cnt-1]

reassembly timeout: 1200 ms

on completion: pass full payload to handler

on timeout: discard buffer

3.6 Deduplication (Device MUST)

Device MUST keep a small cache:

last processed (seq, msg_type) per source MAC (or globally) for at least 10 seconds
If the same (seq, msg_type) is received again:

do not re-apply side effects (e.g., do not write NVS again)

re-send the same ACK/NACK as last time (or recompute response but keep idempotent)

4) Bridge Behavior (ESP-NOW side)
4.1 Peer management (MUST)

Before sending, Bridge MUST esp_now_add_peer() for device_id MAC:

channel 6

encrypt = false

If peer exists, ensure it is valid; otherwise remove+add.

4.2 Sequence numbers

Bridge MUST use monotonically incrementing seq per job (uint16 wrap ok).
For each Serial request:

assign a new seq

use it for all ESP-NOW messages in that job

4.3 ACK/Timeout/Retry (MUST)

For each operation:

wait for matching ACK/NACK from that device MAC and same seq

Retries:

WRITE_CFG: 3 attempts total

READ_CFG: 2 attempts total

APPLY: 2 attempts total

REBOOT: 2 attempts total

When retrying:

resend entire operation (including fragments)

Device dedup prevents duplicate write effects

Timeout:

use Serial timeout_ms if present; otherwise defaults:

WRITE_CFG: 8000ms

READ_CFG: 5000ms

APPLY: 3000ms

REBOOT: 4000ms

On NACK:

return Serial error NACK and include device code/msg in err.msg.

On no response:

return Serial error NO_ACK.

5) Device (Tag/Anchor) Behavior
5.1 Token validation (MUST)

Device MUST validate token from CBOR payload against a configured SHARED_TOKEN.
If invalid:

respond NACK with code="SECURITY_DENIED"

5.2 NVS storage schema (MUST)

Store these keys (minimum):

wifi_ssid (string)

wifi_pass (string)

wifi_dhcp (bool)

mqtt_host (string)

mqtt_port (int)

mqtt_user (string)

mqtt_pass (string)

mqtt_topic_prefix (string)

sys_timezone (string)

sys_log_level (string)

cfg_version (int) increment on each successful write

WRITE_CFG handling:

decode CBOR, validate token, validate required fields (at least wifi.ssid/pass optional rules per project)

write NVS atomically where possible

reply WRITE_ACK on success, else NACK with STORE_FAIL

5.3 APPLY semantics (MUST)

APPLY indicates:

load NVS into runtime config structures

set a flag cfg_applied=true

respond APPLY_ACK

5.4 REBOOT semantics (MUST)

On REBOOT:

send REBOOT_ACK

delay 100–300ms

restart

5.5 READ_CFG semantics (MUST)

On READ_CFG:

validate token

fetch requested fields from NVS (or runtime if applied)

respond READ_ACK with nested map under data

unknown fields: either omit or NACK with INVALID_FIELD (choose one and be consistent; prefer omit for forward compatibility)

6) Bridge Serial ↔ ESP-NOW Mapping
6.1 provision_write

Validate Serial fields and token.

Encode CBOR payload:

{"token":"<shared>","cfg":<cfg_map>}

Send WRITE_CFG → wait WRITE_ACK or NACK.

If apply==true: send APPLY → wait APPLY_ACK.

If reboot==true: send REBOOT → wait REBOOT_ACK.

Return provision_write_ack.

6.2 provision_read

Encode CBOR:

{"token":"<shared>","fields":[...]}

Send READ_CFG → wait READ_ACK.

Decode CBOR data, return as JSON data in Serial response.

6.3 reboot

Send REBOOT → wait REBOOT_ACK → return reboot_ack.

7) Implementation Tasks — Bridge Firmware
B-Task 1: Project skeleton

bridge_main.cpp

modules:

serial_ndjson.cpp/h

pb_proto.cpp/h (header, CRC, fragmentation, reassembly)

espnow_link.cpp/h (peer mgmt, send, recv callback)

job_state.cpp/h (IDLE/BUSY + correlation)

cbor_codec.cpp/h

B-Task 2: Serial NDJSON parser

line buffer 4096

strict JSON parse

write responses as one line

B-Task 3: ESP-NOW init on channel 6

set STA mode, set channel 6, init esp-now

register recv callback

implement send function with pacing between fragments

B-Task 4: Job execution

single job lock

per op: create seq, send, await ack with timeout, retry policy

only accept response from target mac

B-Task 5: CBOR encode/decode

use ArduinoJson CBOR or tinycbor (ESP-IDF)

ensure payload size handling triggers fragmentation

8) Implementation Tasks — Device (Tag/Anchor) Module
D-Task 1: provisioning_espnow.cpp/h

init WiFi STA channel 6

init esp-now

recv callback -> pb parse -> reassembly -> handler

D-Task 2: Command handlers

WRITE_CFG: validate token, store NVS, WRITE_ACK/NACK

READ_CFG: validate token, read NVS, READ_ACK/NACK

APPLY: apply runtime config, APPLY_ACK

REBOOT: REBOOT_ACK then restart

D-Task 3: Dedup cache

store last (seq,msg_type,src_mac) + last response bytes

if duplicate: resend last response

D-Task 4: NVS

implement getters/setters and schema keys above

9) Reference Python Client (Server Side)

Create provision_bridge.py:

open serial port

call(op, payload, timeout) with correlation by id

functions: hello, provision_write, provision_read, reboot

10) Acceptance Tests

hello over serial returns hello_ack

PING (optional internal test) returns PING_ACK

provision_write with small cfg (no fragmentation) succeeds

provision_write with larger cfg triggers fragmentation and succeeds

wrong token -> NACK mapped to Serial status:error err.code="NACK"

simulate dropped frames -> retries succeed and Device does not double-write (cfg_version increments only once)

Final Notes for Codex

Keep Serial output strictly NDJSON responses; no extra debug prints on the same UART.

Use channel 6 everywhere.

Treat device_id as the ESP-NOW peer MAC.

No ESP-NOW encryption.

Wenn du willst, kann ich dir als nächsten Schritt (ohne weitere Fragen) auch gleich die konkreten Code-Skelette (Dateistruktur + Kernklassen + CRC16 + Fragmentierung + State Machine) in C++ (Arduino/ESP-IDF-kompatibel) und das Python-Client-Skript als Startpunkt ausformulieren.